"use strict";(self.webpackChunkhaithong_194=self.webpackChunkhaithong_194||[]).push([[1905],{405:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/tasks-0f19e6173cf908fbda4df78467036ddf.svg"},1522:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/thread_pool-e3483e24df94da18736e05ab5b422140.svg"},2137:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/concurency_vs_paralellism-126855449ca10dc18532569a1ac9c1a7.svg"},2208:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/overview-64566e8566386eecfc6f34790a4db3d2.svg"},2774:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/concurency_vs_paralellism_in_deep-9fb30200b12fed4c8ea528ded156850a.svg"},2883:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/runtime-3c55287f49a4b17b5b70310ef86a9749.svg"},3554:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/3rd_poll-972f60fb17b483ccfa03f9fe904393fd.svg"},5069:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/1st_poll-f7a2e148ca08c1b400644a6ec81e22cc.svg"},5959:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/statemachine-3f9fef705f8667de93663232cf906b22.svg"},6109:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/2nd_poll-ee49eb40f5bcea6e33d90fc3468ac7b2.svg"},7055:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"rust/async/async","title":"Async Await","description":"Overview","source":"@site/docs/rust/async/async.md","sourceDirName":"rust/async","slug":"/rust/async/","permalink":"/docs/rust/async/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rust/async/async.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Dependency Injection","permalink":"/docs/programming_concept/dependency_injection/"},"next":{"title":"Axum","permalink":"/docs/rust/axum/"}}');var r=t(4848),i=t(8453);const l={},a="Async Await",c={},o=[{value:"Overview",id:"overview",level:3},{value:"Concurrency vs Paralellism",id:"concurrency-vs-paralellism",level:3},{value:"Runtime",id:"runtime",level:3},{value:"Async Await",id:"async-await-1",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"async-await",children:"Async Await"})}),"\n",(0,r.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"overview",src:t(2208).A+"",title:"overview",width:"317",height:"317"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"To get a better understand about async-await, we should get to understand about concurrency programming."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"concurrency-vs-paralellism",children:"Concurrency vs Paralellism"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Paralellism & Concurrency is two approachs to handle multiple tasks at the same time."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Paralellism:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each thread handle 1 task."}),"\n",(0,r.jsx)(n.li,{children:"Use multiple threads to handle multiple tasks."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Concurrency:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each thread can handle multiple tasks ->> no need much thread."}),"\n",(0,r.jsx)(n.li,{children:"At a point of time, one thread can execute only 1 task, but the thread can switch between it's tasks."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"concurency_vs_paralellism",src:t(2137).A+"",title:"concurency_vs_paralellism",width:"603",height:"379"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Comments & Questions:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In both approachs, one thread can execute 1 task at a time. Why use Concurrency over Paralellism ?"}),"\n",(0,r.jsx)(n.li,{children:"In the image, it's seem Paralellism can finish the Green Task faster than Concurrency ?"}),"\n",(0,r.jsx)(n.li,{children:"Paralellism can isolated task. It looks much better."}),"\n",(0,r.jsx)(n.li,{children:"How Concurrency knows how to mix the task ?"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The answers for those questions above is inside the task.\r\nConcurrency will show it's advantage when work with the tasks which have to wait for events from I/O.\r\nThe CPU core runs much faster than I/O devices. So, for e.g, it has to wait for I/O drivers to write something to disk, or wait for I/O socket, ...etc."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"tasks",src:t(405).A+"",title:"tasks",width:"283",height:"122"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Idle CPU core is a waste of resource."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In Paralellism, thread must yeild the CPU to another thread, and let the kernel schedule to have chance to run again.\r\nOfcourse, the next thread might belong to another program."}),"\n",(0,r.jsx)(n.li,{children:"In Concurrency, NO yeilding happends. Thread will switch to another task, if current task are waiting for I/O."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"concurency_vs_paralellism_in_deep_",src:t(2774).A+"",title:"concurency_vs_paralellism_in_deep_",width:"663",height:"521"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The image shows that the Green Task might be completed earlier, compare to Paralellism."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"But, Paralellism is easier to implement, because Kernel helps to take care all the threads."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"To implement Concurrency, we need to implement mechanism for thread to be able to hold tasks and switch between tasks.\r\nIt's time for Runtime to comes as a rescuer."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"runtime",children:"Runtime"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The most popular runtime for Rust is ",(0,r.jsx)(n.em,{children:"Tokio runtime"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Runtime provide mechanisms for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Store list of tasks run in concurrency"}),"\n",(0,r.jsx)(n.li,{children:"Which task will be run next"}),"\n",(0,r.jsx)(n.li,{children:"When to re-invoke a pending task"}),"\n",(0,r.jsx)(n.li,{children:"I/O functions for async programming\r\n..."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// example from https://tokio.rs/tokio/tutorial/spawning\r\nuse tokio::net::TcpListener;\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let listener = TcpListener::bind("127.0.0.1:6379").await.unwrap();\r\n\r\n    loop {\r\n        let (socket, _) = listener.accept().await.unwrap();\r\n        // A new task is spawned for each inbound socket. The socket is\r\n        // moved to the new task and processed there.\r\n        tokio::spawn(async move {\r\n            process(socket).await;\r\n        });\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Note for #[tokio::main]"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[tokio::main]\r\nasync fn main() {\r\n    code_inside_main_fn();\r\n}\r\n\r\n// is equivalent to\r\n\r\nfn main() {\r\n    let mut rt = tokio::runtime::Runtime::new().unwrap();\r\n    rt.block_on(async {\r\n        code_inside_main_fn();\r\n    })\r\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Tokio run time has 2 operation mode:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Single-thread runtime: all tasks, executor, reactor are placed inside 1 thread."}),"\n",(0,r.jsx)(n.li,{children:"Multi-thread runtime: using multiple thread to execute tasks (thread pool)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"thread_pool",src:t(1522).A+"",title:"thread pool",width:"462",height:"422"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Bellow is how a task is randomly moved to and be executed in a thread."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The mechanism to drive I/O events is based on Operating System and the system call must be Non-Blocking."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Linux: epoll"}),"\n",(0,r.jsx)(n.li,{children:"Mac: kqueue"}),"\n",(0,r.jsx)(n.li,{children:"Windows: IOCP Input/output completion port"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"runtime",src:t(2883).A+"",title:"runtime",width:"872",height:"1070"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"In Linux, epoll can be use to ask kernel to mornitor for a I/O, which represented by a File Description (fd) number."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Epoll is non-blocking, the result is return immediately."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"epoll",src:t(8069).A+"",title:"epoll",width:"470",height:"462"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"async-await-1",children:"Async Await"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Async Await key words are use to write asynchronous task."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'async fn main {\r\n    asynchronous_task.await();\r\n}\r\n\r\n\r\nasync fn asynchronous_task () -> uszie {\r\n    println!{"hello world"};                    // work\r\n    let n_char = read_from_disk().await();      // wait ...\r\n    return n_char                               // work\r\n}\r\n//  is equivalent with \r\nfn asynchronous_task () -> impl Future<Output = usize> {\r\n    async {\r\n        // ...\r\n    } \r\n}\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Async function is somehow equipvalent with a Future. Let's find out what is Future."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Future is defined as:"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"A future is a value that might not have finished computing yet. This kind of \u201casynchronous value\u201d makes it possible for a thread to continue doing useful work while it waits for the value to become available."}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The Future's defination matchs with the waiting part in our task above."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"tasks",src:t(405).A+"",title:"tasks",width:"283",height:"122"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The core method of future, poll, attempts to resolve the future into a final value"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"We can write a poll funtion in a simplest way:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["call read() with ",(0,r.jsx)(n.em,{children:"O_NON_BLOCKING"})," flag, it means, check with kernel if a FD is ready to read."]}),"\n",(0,r.jsxs)(n.li,{children:["if fd is ready, the data is return from ",(0,r.jsx)(n.em,{children:"read()"}),", future is done."]}),"\n",(0,r.jsxs)(n.li,{children:["if fd is not ready, ",(0,r.jsx)(n.em,{children:"read()"})," returns ",(0,r.jsx)(n.em,{children:"WOULD_BLOCK"})," ->> ask waker to monitor the fd."]}),"\n",(0,r.jsx)(n.li,{children:"the poll will be called again, when waker signals executor."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// simplest future\r\nfn poll(waker) {\r\n\r\n    let r = read(fd, ops, O_NON_BLOCKING);\r\n\r\n    if r == OK {\r\n        return r.data;\r\n    }\r\n\r\n    if r == WOULD_BLOCK {\r\n        wake.push(fd, ops);\r\n    }\r\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"How to write a complex Future."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"And how the poll() function knows where to continue for the 2nd poll."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// nested poll function\r\nfn poll () {\r\n    // work before read\r\n    // future 1\r\n    fut_read_socket.await();\r\n    // work before write\r\n    // future 2\r\n    fut_write_socket.await();\r\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Actually, before the introduction of async-await, async task was implemented as a State Machine."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'Enum State<T> {\r\n    State_Start,\r\n    State_Reading(Option<T>),    // before read() completed\r\n    State_Writing(x, y, z),     // before write() completed\r\n    State_End,\r\n}\r\n\r\nimpl<T> Future for State {\r\n    type Output = ();\r\n\r\n    fn poll(&mut self) -> Poll<Self::Output> {\r\n        \r\n        match self {\r\n\r\n            State::State_Start => {\r\n                println!{"some work before Read"};\r\n\r\n                // change state\r\n                *self = State::State_Reading(data, ...);\r\n                return self.poll();\r\n            }\r\n\r\n            State::State_Reading(data, ...) => {\r\n\r\n                if let Poll::Ready() = fut_read_socket.poll() {\r\n\r\n                    println!{"some work before Write"};\r\n            \r\n                    // change state\r\n                    *self = State::State_Writing(data, ...);\r\n                    return self.poll();\r\n                }\r\n                else {\r\n                    Poll::Pending\r\n                }\r\n            }\r\n        \r\n        State::State_Writing(data, ...) => {\r\n\r\n                if let Poll::Ready() = fut_write_socket.poll() {\r\n                \r\n                    // change state\r\n                    *self = State::State_End;\r\n                    return self.poll();\r\n                }\r\n                else {\r\n                    Poll::Pending\r\n                }\r\n            }\r\n\r\n            State::State_End => {\r\n                Poll::Ready(())\r\n            }\r\n            \r\n        }\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"By using state machine, we can ensure that we can call poll() function multiple time but some logic is not be executed more than once."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"statemachine",src:t(5959).A+"",title:"statemachine",width:"302",height:"342"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The detail of how state machine work"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"1st_poll",src:t(5069).A+"",title:"1st_poll",width:"592",height:"582"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"2nd_poll",src:t(6109).A+"",title:"2nd_poll",width:"503",height:"497"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"3rd_poll",src:t(3554).A+"",title:"3rd_poll",width:"642",height:"642"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8069:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/epoll-8b496455764f40c5e8f4bdd8a120c545.svg"},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkhaithong_194=self.webpackChunkhaithong_194||[]).push([[2921],{3371:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"rust/closure/closure","title":"closure","description":"1. Closure","source":"@site/docs/rust/closure/closure.md","sourceDirName":"rust/closure","slug":"/rust/closure/","permalink":"/docs/rust/closure/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rust/closure/closure.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\\\\#[Derive Clone]","permalink":"/docs/rust/clone/derive_clone"},"next":{"title":"Database","permalink":"/docs/rust/database/"}}');var s=r(4848),t=r(8453);const o={},c=void 0,i={},a=[{value:"1. Closure",id:"1-closure",level:3},{value:"Closure implement Fn trait",id:"closure-implement-fn-trait",level:4},{value:"Closure implement FnMut trait",id:"closure-implement-fnmut-trait",level:4},{value:"Closure implement FnOnce trait",id:"closure-implement-fnonce-trait",level:4}];function u(e){const n={code:"code",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"1-closure",children:"1. Closure"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Think of closure as lambdas in C++, or arrow function in JavaScript."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Closure is a combination of a function and a set of data (captured data)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Or closure is a Trait object. There are 3 Traits: Fn, FnMut, FnOnce"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"closure-implement-fn-trait",children:"Closure implement Fn trait"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Closure which implements Fn trait uses immutable reference to captures data, that why it can be called multiple times."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let color = String::from("green");\r\nlet print = || println!("color: {}", color);  \r\n// print is a closure\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// desugar syntactic:\r\nstruct PrintClosure {\r\n    color: & String,\r\n    // borrow **immutable** ownership of the real color value\r\n}\r\nimpl Fn for PrintClosure {\r\n    fn call(&self) {\r\n        println!("color: {}", self.color);  \r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"fn_closure.svg",src:r(7608).A+"",title:"Memory map of closure as Fn Trait Object",width:"344",height:"250"})}),"\n",(0,s.jsx)(n.h4,{id:"closure-implement-fnmut-trait",children:"Closure implement FnMut trait"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This kind of closure use mutable reference to capture data."}),"\n",(0,s.jsx)(n.li,{children:"When closure is created, we can not create reference to the captured-data until the closure is removed, because Rust allows only 1 mutable reference at a moment."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let mut count = 0;\r\nlet mut inc = || {      // notice: inc is mutable closure\r\n    count += 1;\r\n    println!("count: {}", count);\r\n};\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// desugar syntactic:\r\nstruct IncClosure {\r\n    count: &mut i32,\r\n    // borrow **mutable** ownership of the count value\r\n}\r\nimpl FnMut for IncClosure {\r\n    fn call_mut(&self) {\r\n        println!("color: {}", self.color);  \r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"closure-implement-fnonce-trait",children:"Closure implement FnOnce trait"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"This closure takes ownership of captured-data."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Approach 1: Use FnOnce closure when the capture data is drop at the first call."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let movable = Box::new(3);\r\nlet consume = || {\r\n    println!("movable: {:?}", movable);\r\n    mem::drop(movable);\r\n};\r\n// from now, movable lost it\'s value, can not be used\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// desugar syntactic:\r\nstruct ConsumeClosure {\r\n    movable: Box<i32>,\r\n}\r\nimpl FnOnce for ConsumeClosure {\r\n    fn call_once(&self) {\r\n        println!("movable: {:?}", self.movable);\r\n        mem::drop(self.movable);\r\n        // "drop" causes this closure can be called only 1 time.\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Approach 2: Use the FnOnce closure to capture inner data."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For e.g: The ",(0,s.jsx)(n.strong,{children:"local_string"})," will outlive the closure returned by create_closure()."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn create_closure() -> impl Fn() {\r\n    let local_string = String::from("hello");\r\n\r\n    // return a closure\r\n    || {\r\n        // compiler might create a Fn closure\r\n        println!("local: ", local_string);\r\n    }\r\n\r\n    // local_string is destroyed, the memory which contains "hello" is removed\r\n}\r\n\r\n// call closure here return an error\r\nlet created_closure = create_closure();\r\ncreated_closure();   // error\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Using ",(0,s.jsx)(n.strong,{children:"move"})," to move the value to inside closure, forces closure to take ownership. Also means that compiler will create FnOnce closure"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn create_closure() -> impl Fn() {\r\n    let local_string = String::from("hello");\r\n\r\n    move || {\r\n        println!("local: ", local_string);\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// desugar syntactic:\r\nstruct AnonymousClosure {\r\n    local_string: String,\r\n    // local_string will be move to AnonymousClosure.local_string\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"move_closure.svg",src:r(6403).A+"",title:"Move closure",width:"374",height:"182"})})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},6403:(e,n,r)=>{r.d(n,{A:()=>l});const l=r.p+"assets/images/move_closure-d7e128421e3be6196152a982bb2197b2.svg"},7608:(e,n,r)=>{r.d(n,{A:()=>l});const l=r.p+"assets/images/fn_closure-3d0d0b29fec92b83e96b069d884c651f.svg"},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var l=r(6540);const s={},t=l.createContext(s);function o(e){const n=l.useContext(t);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),l.createElement(t.Provider,{value:n},e.children)}}}]);